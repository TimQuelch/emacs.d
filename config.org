#+property: header-args :results silent :tangle config.el :noweb yes

* Doom modules
:PROPERTIES:
:header-args: :tangle no :results silent :noweb-ref doom-modules
:END:

All my doom modules appear in the following sections
#+begin_src emacs-lisp :tangle init.el :noweb yes :noweb-ref no
(doom!
 <<doom-modules>>
 )
#+end_src

** Completion
I'm using company as my inline completion framework, and helm as my navigation/completion/ui completion framework
#+begin_src emacs-lisp
:completion
(company +childframe)
(helm +fuzzy)
#+end_src

** UI
I enable various UI improvements and such here
#+begin_src emacs-lisp
:ui
doom
modeline
nav-flash
ophints
(popup +all +defaults)
pretty-code
treemacs
vc-gutter
vi-tilde-fringe
window-select
#+end_src

** Editor
I use evil keybindings everywhere. I also want to format buffers when I save them
#+begin_src emacs-lisp
:editor
(evil +everywhere)
(format +onsave)
#+end_src

** Emacs
Improve dired, version-control, and parenthesis behaviour
#+begin_src emacs-lisp
:emacs
(dired +icons)
electric
vc
#+end_src

** Terminal
Vterm is the best term
#+begin_src emacs-lisp
:term
vterm
#+end_src

** Checkers
Enable syntax and spell checkers
#+begin_src emacs-lisp
:checkers
syntax
spell
#+end_src

** Tools
Set up a bunch of extra functionality in emacs
#+begin_src emacs-lisp
:tools
(eval +overlay)                         ; evaluation
docker                                  ; docker
lookup                                  ; lookup of definitions/docs
(lsp +peek)                             ; enable language server
(magit +forge)                          ; git wizardry
pdf                                     ; pdf viewing and annotation
#+end_src

** Languages
Enable lots of programming language integrations
#+begin_src emacs-lisp
:lang
(cc +lsp)
emacs-lisp
data
json
latex
markdown
(org +jupyter +noter +roam +journal)
(python +lsp)
(sh +fish)
#+end_src

** Config
Enable bindings and also tell Doom that I'm using a literate config
#+begin_src emacs-lisp
:config
literate
(default +bindings +smartparens)
#+end_src
* Personalisation
Setup name and email
#+begin_src emacs-lisp
(setq user-full-name "Tim Quelch"
      user-mail-address "tim@quelch.name")
#+end_src

* UI
Use some nice fonts
#+begin_src emacs-lisp
(setq doom-font (font-spec :family "Iosevka" :size 18)
      doom-variable-pitch-font (font-spec :family "DejaVu Sans"))
#+end_src

Set the theme
#+begin_src emacs-lisp
(setq doom-one-brighter-comments t
      doom-one-comment-bg nil
      doom-theme 'doom-one)
#+end_src

Display line numbers
#+begin_src emacs-lisp
(setq display-line-numbers-type t)
#+end_src

Set up ~fill-column~ to be wider by default
#+begin_src emacs-lisp
(setq-default fill-column 100)
#+end_src

Increase the amount of context lines when scrolling full screenfuls (default is 2)
#+begin_src emacs-lisp
(setq next-screen-context-lines 8)
#+end_src

Wrap lines at fill column when using ~visual-line-mode~
#+begin_src emacs-lisp :tangle packages.el
(package! visual-fill-column)
#+end_src
#+begin_src emacs-lisp
(use-package visual-fill-column
  :hook (visual-line-mode . visual-fill-column-mode)
  :config
  (setq-default split-window-preferred-function
                'visual-fill-column-split-window-sensibly))
#+end_src

Only enable ~pretty-symbols~ in some reasonable modes
#+begin_src emacs-lisp
(setq +pretty-code-enabled-modes '(org-mode))
#+end_src

Set up ~mixed-pitch-mode~ in text modes. Proportional fonts are much nicer to read, but I still want fixed pitch in code blocks
#+begin_src emacs-lisp :tangle packages.el
(package! mixed-pitch)
#+end_src
#+begin_src emacs-lisp
(use-package mixed-pitch
  :hook (text-mode . mixed-pitch-mode)
  :config
  (pushnew! mixed-pitch-fixed-pitch-faces
            'org-date
            'org-special-keyword
            'org-property-value
            'org-drawer
            'org-ref-cite-face
            'org-tag
            'org-todo-keyword-todo
            'org-todo-keyword-habt
            'org-todo-keyword-done
            'org-todo-keyword-wait
            'org-todo-keyword-kill
            'org-todo-keyword-outd
            'org-todo
            'org-done
            'font-lock-comment-face
            'line-number
            'line-number-current-line))
#+end_src

* Helm
Use heading of helm as input line
#+begin_src emacs-lisp
(after! helm
  (setq helm-echo-input-in-header-line t)
  (add-hook 'helm-minibuffer-set-up-hook 'helm-hide-minibuffer-maybe))
#+end_src

Increase size of helm buffers
#+begin_src emacs-lisp
(after! helm
  (set-popup-rule! "^\\*helm" :size 0.3))
#+end_src

* Editing
Enable the use of =C-u= as the universal argument again
#+begin_src emacs-lisp
(after! evil
  (setq! evil-want-C-u-delete nil
         evil-want-C-u-scroll nil))
#+end_src

Use better comment dwim
#+begin_src emacs-lisp :tangle packages.el
(package! comment-dwim-2)
#+end_src
#+begin_src emacs-lisp
(use-package! comment-dwim-2
  :bind ([remap comment-dwim] . comment-dwim-2)
  :config (setq cd2/region-command 'cd2/comment-or-uncomment-region))
#+end_src

Disable some extra packages that I don't really use
#+begin_src emacs-lisp :tangle packages.el
(disable-packages! evil-snipe evil-lion)
#+end_src
* Org and friends
** Base
#+begin_src emacs-lisp
(setq org-directory "~/documents/org/")
#+end_src

#+begin_src emacs-lisp
(after! org
  <<org-configuration>>
  )
#+end_src

Setting up ~TODO~ states. ~WAITING~ and ~CANCELLED~ require messages when entering these states. I'm trying not to use the ~EMAIL~ state, but keeping it here for archive purposes.
#+begin_src emacs-lisp  :tangle no :noweb-ref org-configuration
(setq org-todo-keywords '((sequence "TODO(t)" "NEXT(n)" "WAITING(w@/!)" "|" "DONE(d)")
                          (sequence "EMAIL(e)" "|" "SENT(s)")
                          (sequence "|" "CANCELLED(c@/!)")
                          (sequence "|" "MOVED(m)")))
#+end_src

Ensure that sub-tasks must be completed before the parent task can be marked done
#+begin_src emacs-lisp :tangle no :noweb-ref org-configuration
(setq org-enforce-todo-dependencies t)
#+end_src

Log the time when tasks are completed
#+begin_src emacs-lisp :tangle no :noweb-ref org-configuration
(setq org-log-done 'time)
#+end_src

Setup refile targets. Targets include the current file and all agenda files (files in the org directory) up to 9 levels deep in the hierarchy. Only in-progress tasks are allowed as refile targets
#+begin_src emacs-lisp :tangle no :noweb-ref org-configuration
(setq org-refile-allow-creating-parent-nodes 'confirm)
(setq org-refile-targets '((nil :maxlevel . 9)
                           (org-agenda-files :maxlevel . 9)))

(defun tq/verify-refile-target ()
  "Exclude done todo states from refile targets"
  (not (member (nth 2 (org-heading-components)) org-done-keywords)))
(setq org-refile-target-verify-function 'tq/verify-refile-target)
#+end_src

Use the outline path as the refile target. This can be completed in steps to work well with helm etc.
#+begin_src emacs-lisp :tangle no :noweb-ref org-configuration
(setq org-refile-use-outline-path t)
(setq org-outline-path-complete-in-steps nil)
#+end_src

Don't log when changing state with shift-arrows
#+begin_src emacs-lisp :tangle no :noweb-ref org-configuration
(setq org-treat-S-cursor-todo-selection-as-state-change nil)
#+end_src

Log state changes into drawers rather than under the items istelf. This is also important for habits
#+begin_src emacs-lisp :tangle no :noweb-ref org-configuration
(setq org-log-into-drawer t)
#+end_src

Pressing return over links will follow the link
#+begin_src emacs-lisp :tangle no :noweb-ref org-configuration
(setq org-return-follows-link t)
#+end_src

Archive to subdirectory and use datetree
#+begin_src emacs-lisp
(after! org-archive
  (setq org-archive-location "archive/%s_archive::datetree/"))
#+end_src

Highlight LaTeX within ~org~
#+begin_src emacs-lisp :tangle no :noweb-ref org-configuration
(setq org-highlight-latex-and-related '(native script entities))
#+end_src

Enable the use of org-ids for links to headlines. ~org-id-track-globally~ is on by default in doom, however this only updates the org id file when emacs exits, so IDK if it will work very well for me using a daemoned emacs.
#+begin_src emacs-lisp :tangle no :noweb-ref org-configuration
(setq org-id-link-to-org-use-id 'create-if-interactive)
#+end_src

Disable some of the extra things that Doom enables
#+begin_src emacs-lisp :tangle packages.el
(disable-packages! org-superstar)
#+end_src

** Agenda

I use ~org-super-agenda~ to group tasks in agenda
#+begin_src emacs-lisp emacs-lisp :tangle packages.el
(package! org-super-agenda)
#+end_src
#+begin_src emacs-lisp
(use-package! org-super-agenda
  :hook (org-agenda-mode . org-super-agenda-mode))

(after! (org-agenda org-super-agenda)
  (setq! org-super-agenda-header-map (make-sparse-keymap)))
#+end_src

Map agenda to a more convenient binding
#+begin_src emacs-lisp
(map! :leader "a" #'org-agenda)
#+end_src

Next I want to configure the agenda behaviour
#+begin_src emacs-lisp
(after! org-agenda
  <<org-agenda-configuration>>
  <<org-agenda-filters>>
  <<org-agenda-views>>
  )
#+end_src

When opening an item from the agenda, ensure the whole tree (parents and siblings) is visible
#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda-configuration
(add-hook 'org-agenda-after-show-hook 'org-reveal)
#+end_src

Don't dim blocked tasks (i.e. projects)
#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda-configuration
(setq org-agenda-dim-blocked-tasks nil)
#+end_src

Remove the 'category' header from the agenda. Because I only really use one main agenda file, this was the same for all the values in the agenda. Removing it gives me some more horizontal space in the agenda view.
#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda-configuration
(setq org-agenda-prefix-format '((agenda . " %i %?-12t% s")
                                 (todo . " %i ")
                                 (tags . " %i ")
                                 (search . " %i ")))
#+end_src

I also remap movement keys to move between agenda items rather than between lines, as this is what you want to do the vast majority of the time.
#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda-configuration
(map! :map org-agenda-mode-map
      [remap org-agenda-next-line] #'org-agenda-next-item
      [remap org-agenda-previous-line] #'org-agenda-previous-item)
#+end_src

Set up some other useful bindings
#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda-configuration
(map! :map org-agenda-mode-map
      :m "w" #'org-save-all-org-buffers
      :m "f" #'org-agenda-follow-mode)
#+end_src

Enable habits
#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda-configuration
(add-to-list 'org-modules 'org-habit)
#+end_src

*** Agenda views
:PROPERTIES:
:header-args: :noweb-ref org-agenda-views :tangle no
:END:

Setup the groups that appear in the agenda views.

#+begin_src emacs-lisp
(setq org-super-agenda-groups
      '((:name "Waiting"
         :todo "WAITING"
         :order 103)
        (:name "Emails"
         :tag "email"
         :order 3)
        (:name "Housework"
         :tag "home"
         :order 100)
        (:name "To read"
         :tag "toread"
         :order 4)
        (:name "Work"
         :tag "work"
         :order 5)
        (:name "Habits"
         :habit t
         :order 101)
        (:name "Configuration"
         :tag "config"
         :order 102)))
#+end_src

I want to see emails high up, because usually they are pretty quick to do. Housework and habits I don't want to see until lower in the agenda, because they are usually low priority. Configuration to do in emacs or my OS is incredibly low priority so I want to see that last.

Any items that do not fall in one of these filter categories goes in an automatic 'Other Items' section which has an order of 99 (so will appear before anything with an order >99)

Below I'm setting up my main agenda view as well as a projects view
#+begin_src emacs-lisp :noweb yes
(setq org-agenda-custom-commands
      '(("j" "Super agenda" (
                             <<agenda-custom-commands>>
                             ))
        ("p" "Projects" (
                         <<agenda-projects-custom-commands>>
                         ))))
#+end_src

**** Super agenda
:PROPERTIES:
:header-args: :noweb-ref agenda-custom-commands :tangle no :results silent
:END:
The first view is today's agenda, for tasks scheduled today (or in the past) or with deadlines coming up. I include at schedule at the top
#+begin_src emacs-lisp
(agenda "" ((org-super-agenda-groups
             (cons '(:name "Schedule" :time-grid t) org-super-agenda-groups))
            (org-agenda-span 'day)
            (org-agenda-start-day)))
#+end_src

The next section is the Inbox. These are items that I have captured quickly and need to be refiled into my main agenda file.
#+begin_src emacs-lisp
(tags "inbox"
      ((org-agenda-overriding-header "Inbox")
       (orgs-tag-match-list-sublevels nil)))
#+end_src

This section shows projects which are stuck. I define projects as todo items with sub todo items. A stuck project is a project where none of the sub-todos has a NEXT keyword. These are projects where I don't have a task to go onto next. I want to see these because I need to go into these projects and evaluate what tasks I can begin next
#+begin_src emacs-lisp
(todo "" ((org-agenda-overriding-header "Stuck projects")
          (org-agenda-skip-function 'tq/skip-all-but-stuck-projects)))

#+end_src

This section shows tasks and projects which are available to be completed (e.g. they are standalone tasks or sub-tasks with a NEXT keyword) but are unscheduled. I want to see these because I need to schedule them to complete sometime.
#+begin_src emacs-lisp
(todo "" ((org-agenda-overriding-header "Unscheduled available todos")
          (org-agenda-skip-function 'tq/skip-all-but-available-unscheduled-todos)))
#+end_src

**** Projects view
:PROPERTIES:
:header-args: :noweb-ref agenda-projects-custom-commands :tangle no :results silent
:END:
The project view is for viewing all of my current projects (including subprojects for now)
#+begin_src emacs-lisp
(todo "" ((org-agenda-skip-function #'tq/skip-all-but-projects)))
#+end_src

*** Agenda filters
:PROPERTIES:
:header-args: :noweb-ref org-agenda-filters :tangle no :results silent
:END:

Functions that I use to filter the agenda
#+begin_src emacs-lisp
(defun tq/is-todo-p ()
  (member (nth 2 (org-heading-components)) org-todo-keywords-1))

(defun tq/has-subtodo-p ()
  (save-restriction
    (widen)
    (let ((has-subtodo)
          (subtree-end (save-excursion (org-end-of-subtree t))))
      (save-excursion
        (forward-line 1)
        (while (and (not has-subtodo)
                    (< (point) subtree-end)
                    (re-search-forward org-heading-regexp subtree-end t))
          (when (tq/is-todo-p)
            (setq has-subtodo t))))
      has-subtodo)))

(defun tq/is-project-p ()
  "Is a project. i.e. A todo (with a todo keyword) that has at least one subtodo (with a todo keyword)"
  (and (tq/is-todo-p) (tq/has-subtodo-p)))

(defun tq/is-task-p ()
  "Is a task. i.e. A todo (with a todo keyword) that has no subtodos (with a todo keyword)"
  (and (tq/is-todo-p) (not (tq/has-subtodo-p))))

(defun tq/is-subtodo-p ()
  "Is todo (either a task or a project) that is part of a project"
  (save-restriction
    (widen)
    (let ((is-subtodo)
          (is-a-todo (tq/is-todo-p)))
      (when is-a-todo
        (save-excursion
          (while (and (not is-subtodo)
                      (org-up-heading-safe))
            (when (tq/is-todo-p)
              (setq is-subtodo t)))))
      (and is-a-todo is-subtodo))))

(defun tq/is-subproject-p ()
  "Is task that is part of a project"
  (and (tq/is-subtodo-p) (tq/is-project-p)))

(defun tq/is-subtask-p ()
  "Is task that is part of a project"
  (and (tq/is-subtodo-p) (tq/is-task-p)))

(defun tq/is-standalone-project-p ()
  "Is project that is not part of a project"
  (and (not (tq/is-subtodo-p)) (tq/is-project-p)))

(defun tq/is-standalone-task-p ()
  "Is task that is not part of a project"
  (and (not (tq/is-subtodo-p)) (tq/is-task-p)))

(defvar tq/next-todo-keyword "NEXT"
  "The todo keyword indicating the next task in a project. Any project without at least one subtask with this keyword is considered stuck")

(defun tq/is-stuck-project-p ()
  "Is a project that is stuck"
  (when (tq/is-project-p)
    (let ((subtree-end (save-excursion (org-end-of-subtree t)))
          (next-regexp (concat org-outline-regexp-bol tq/next-todo-keyword " ")))
      (forward-line 1)
      (not (re-search-forward next-regexp subtree-end t)))))

(defun tq/skip-all-but-stuck-projects ()
  "Skip trees that are not stuck projects"
  (save-restriction
    (widen)
    (unless (tq/is-stuck-project-p)
      (save-excursion (or (outline-next-heading) (point-max))))))

(defun tq/skip-all-but-available-unscheduled-todos ()
  "Skip todos that are unavailable or available but already scheduled. Available todos are standalone tasks or NEXT tasks"
  (save-restriction
    (widen)
    (unless (and (or (tq/is-standalone-task-p)
                     (string-equal (org-get-todo-state) tq/next-todo-keyword))
                 (not (org-get-scheduled-time nil)))
      (save-excursion (or (outline-next-heading) (point-max))))))

(defun tq/skip-all-but-projects ()
  "Skip trees that are not projects"
  (save-restriction
    (widen)
    (unless (tq/is-project-p)
      (save-excursion (or (outline-next-heading) (point-max))))))
#+end_src
** Capture
Bind capture to something more convenient
#+begin_src emacs-lisp
(map! :leader "j" #'org-capture)
#+end_src

Configure my capture templates. ~e~ is not intended to be used interactively, and is only used from ~notmuch~ (maybe I could let bind this??)
#+begin_src emacs-lisp
(after! org-capture
  (setq org-default-notes-file (expand-file-name "inbox.org" org-directory))

  (setq org-capture-templates
        '(("t" "todo" entry (file org-default-notes-file)
           "* TODO %?\n%U\n" :clock-in t :clock-resume t)
          ("n" "note" entry (function (lambda ()
                                        (org-journal-new-entry t)
                                        (while (org-up-heading-safe))))
           "* %(format-time-string org-journal-time-format)%?\n%i")
          ("a" "appointment" entry (file org-default-notes-file)
           "* %?\n%U\n" :clock-in t :clock-resume t))))
#+end_src
** Referencing

Define my default bibliography file (generated and maintained by Zotero/BBL)
#+begin_src emacs-lisp
(defvar tq/bibliography-file "~/documents/library.bib")
#+end_src

I'm using ~org-ref~ to manage citations within org-mode. This might soon be replaced by native citation support though :o
#+begin_src emacs-lisp :tangle packages.el
(package! org-ref)
#+end_src
#+begin_src emacs-lisp
(use-package! org-ref
  :after org
  :defer-incrementally t
  :init
  (setq! org-ref-default-bibliography (list tq/bibliography-file)
         org-ref-default-citation-link "autocite"))
#+end_src

Use ~helm-bibtex~ as the main way of dealing with bibliographies
#+begin_src emacs-lisp :tangle packages.el
(package! helm-bibtex)
#+end_src
#+begin_src emacs-lisp
(use-package! helm-bibtex
  :after org-ref
  :config
  (setq! bibtex-completion-pdf-field "file"
         helm-bibtex-full-frame nil))
#+end_src

** Exporting
#+begin_src emacs-lisp
(use-package ox-extra
  :after org
  :config
  (ox-extras-activate '(ignore-headlines)))
#+end_src

#+begin_src emacs-lisp
(use-package ox-latex
  :after org
  :config
  (add-to-list 'org-latex-classes '("a4article"
                                    "\\documentclass[11pt,a4paper]{article}"
                                    ("\\section{%s}" . "\\section*{%s}")
                                    ("\\subsection{%s}" . "\\subsection*{%s}")
                                    ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                                    ("\\paragraph{%s}" . "\\paragraph*{%s}")
                                    ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
  (setq org-latex-default-class "a4article")
  (setq org-latex-packages-alist '(("titletoc, title" "appendix" nil) ; Setup appendices
                                   ("margin=25mm" "geometry")         ; Setup margins
                                   ("" "tocbibind" nil)  ; Put bibliography in TOC
                                   ("" "pdflscape" nil)  ; Allow landscape pages
                                   ("" "pdfpages" nil)   ; Allow inclusion of pdfs
                                   ("" "svg" nil)        ; Allow SVG images (req. inkscape?)
                                   ("" "subcaption" nil) ; Allow subcaptions
                                   ("" "listings" nil)   ; Source code listings
                                   ("" "color" nil)      ; Color in source code listings
                                   ("binary-units" "siunitx" t)))     ; SI units

  (setq org-latex-default-packages-alist (remove '("" "hyperref" nil) org-latex-default-packages-alist))
  (add-to-list 'org-latex-default-packages-alist '("hidelinks" "hyperref" nil))
  (add-to-list 'org-latex-default-packages-alist "\\PassOptionsToPackage{hyphens}{url}")

  (setq org-latex-pdf-process (->> org-latex-pdf-process
                                   (--map (->> it
                                               (s-chop-suffix "%f")
                                               (s-append "-shell-escape %f")))))

  (setq org-latex-listings t)                                         ; Turn on source code inclusion
  (setq org-latex-listings-options '(("basicstyle" "\\linespread{0.85}\\ttfamily")
                                     ("numbers" "left")
                                     ("numberstyle" "\\tiny")
                                     ("frame" "tb")
                                     ("tabsize" "4")
                                     ("columns" "fixed")
                                     ("showstringspaces" "false")
                                     ("showtabs" "false")
                                     ("keepspaces" "true")
                                     ("commentstyle" "\\color{red}")
                                     ("keywordstyle" "\\color{blue}")
                                     ("breaklines" "true"))))
#+end_src
** Notetaking
*** Roam
Setup ~org-roam~, ~org-roam-bibtex~, and ~org-roam-server~ to track source
#+begin_src emacs-lisp :tangle packages.el
(package! org-roam :recipe (:host github :repo "org-roam/org-roam"))
(package! org-roam-bibtex :recipe (:host github :repo "org-roam/org-roam-bibtex"))
(package! org-roam-server :recipe (:host github :repo "org-roam/org-roam-server"))
(unpin! org-roam org-roam-bibtex org-roam-server)
#+end_src

Set directory for my ~org-roam~ notes
#+begin_src emacs-lisp
(setq org-roam-directory (concat (file-name-as-directory org-directory) "notes"))
#+end_src

Set up more useful keybindings to use and access ~org-roam~
#+begin_src emacs-lisp
(map! :leader
      :prefix "n"
      "f" #'org-roam-find-file
      :map org-roam-mode-map
      "i" #'org-roam-insert
      "g" #'org-roam-graph
      "r" #'org-roam)
#+end_src

Do remaining configuration after ~org-roam~ is loaded
#+begin_src emacs-lisp
(after! org-roam
  <<org-roam-config>>
  )
#+end_src

Put the database in the doom cache directory, rather than stored with the notes
#+begin_src emacs-lisp :tangle no :noweb-ref org-roam-config
(setq org-roam-db-location (concat doom-cache-dir "org-roam.db"))
#+end_src

Turn back on verbosity. I like the messages
#+begin_src emacs-lisp :tangle no :noweb-ref org-roam-config
(setq org-roam-verbose t)
#+end_src

Set up capture template
#+begin_src emacs-lisp :tangle no :noweb-ref org-roam-config
(setq org-roam-capture-templates
      '(("d" "default" plain (function org-roam-capture--get-point)
         "%?"
         :file-name "%<%Y%m%d%H%M%S>-${slug}"
         :head "#+title: ${title}\n"
         :unnarrowed t
         :immediate-finish t)))
#+end_src

Ensure tags come from both the directory and the ~roam_tag~ file property. The default is just the property
#+begin_src emacs-lisp :tangle no :noweb-ref org-roam-config
(setq org-roam-tag-sources '(prop all-directories))
#+end_src

Exclude daily notes from the graph
#+begin_src emacs-lisp :tangle no :noweb-ref org-roam-config
(setq org-roam-graph-exclude-matcher '("daily/"))
#+end_src

Set up an agenda view for nearby notes
#+begin_src emacs-lisp
(defun tq/org-agenda-nearby-notes (&optional distance)
  (interactive "P")
  (let ((org-agenda-files (org-roam-db--links-with-max-distance
                           buffer-file-name (or distance 3)))
        (org-agenda-custom-commands '(("e" "" ((alltodo ""))))))
    (org-agenda nil "e")))

(map! :leader :prefix "n" :desc "Agenda nearby" "a" #'tq/org-agenda-nearby-notes)
#+end_src

Set up a graph view where citation links are excluded
#+begin_src emacs-lisp
(defun tq/org-roam-graph-without-cites (&optional arg)
  (interactive "P")
  (let ((org-roam-graph-exclude-matcher (cons "lit/" org-roam-graph-exclude-matcher)))
    (org-roam-graph-show arg)))

(map! :leader :prefix "n" "G" #'tq/org-roam-graph-without-cites)
#+end_src
*** Journal
I want to use ~org-journal~ as the way to capture and navigate my daily and fleeting notes
#+begin_src emacs-lisp
(after! org-journal
  <<org-journal-configuration>>
  )
#+end_src

Set the journal directory to be inside my roam directory
#+begin_src emacs-lisp :tangle no :noweb-ref org-journal-configuration
(setq org-journal-dir (expand-file-name "daily/" org-roam-directory))
#+end_src

I want to use a weekly journal file. This should make weekly reviews somewhat easier and will result in fewer overall files
#+begin_src emacs-lisp :tangle no :noweb-ref org-journal-configuration
(setq org-journal-file-type 'weekly)
#+end_src

Setup file header. This will likely put the date on the first one that I actually create the entry, and not only Monday. This is ok though.
#+begin_src emacs-lisp :tangle no :noweb-ref org-journal-configuration
(setq org-journal-file-header "#+title: Weekly journal for %F")
#+end_src

Set file format to use a .org extension. No idea why this isn't the default
#+begin_src emacs-lisp :tangle no :noweb-ref org-journal-configuration
(setq org-journal-file-format "%Y-%m-%d.org")
#+end_src

Don't carryover any items
#+begin_src emacs-lisp :tangle no :noweb-ref org-journal-configuration
(setq org-journal-carryover-items nil)
#+end_src

Add more convenient mappings for journal access
#+begin_src emacs-lisp
(map! :leader :prefix "n"
      :desc "Journal entry"   "n" #'org-journal-new-entry
      :desc "Today's journal" "t" (cmd!! #'org-journal-new-entry t))
#+end_src

#+begin_src emacs-lisp
(defun tq/refile-to-inbox ()
  (interactive)
  (let ((id (org-id-get-create)))
    (org-refile 3 nil (list org-default-notes-file org-default-notes-file nil nil))
    (org-edit-headline (concat "[[id:" id "][HERE]] " (nth 4 (org-heading-components))))
    (let ((new-id (org-id-get-create t)))
      (save-window-excursion
        (org-id-goto id)
        (org-set-property "ORIGIN" (concat "[[id:" new-id "]]")))))
  (org-todo "MOVED"))
#+end_src

*** Bibtex
Enable ~org-roam-bibtex~ and setup capture template
#+begin_src emacs-lisp
(use-package org-roam-bibtex
  :commands (org-roam-bibtex-insert-non-ref org-roam-bibtex-find-non-ref)
  :hook (org-roam-mode . org-roam-bibtex-mode)
  :config
  (setq orb-templates
        `(("r" "ref" plain
           (function org-roam-capture--get-point)
           ""
           :file-name ,(concat (file-name-as-directory "lit") "%<%Y%m%d%H%M%S>-${slug}")
           :head "#+title: Notes on: ${title}\n#+roam_key: ${ref}\n"
           :unnarrowed t
           :immediate-finish t))))
#+end_src

Enable ~org-server~
#+begin_src emacs-lisp
(use-package org-roam-server
  :hook (org-roam-mode . org-roam-server-mode))
#+end_src

*** Noter
I don't like the configuration in Doom's ~org-noter~ module so I do it myself
#+begin_src emacs-lisp :tangle packages.el
(package! org-noter)
#+end_src
#+begin_src emacs-lisp
(use-package org-noter
  :defer t
  :config
  (map! :map org-noter-doc-mode-map
        :leader :n "i" #'org-noter-insert-note))
#+end_src

Disable ~org-pdftools~ because it breaks ~org-noter~ in ~nov~ mode
#+begin_src emacs-lisp :tangle packages.el
(disable-packages! org-pdftools)
#+end_src
** Babel
I'm mostly happy with doom's configuration for jupyter
#+begin_src emacs-lisp
(after! jupyter
  (setq org-babel-default-header-args:jupyter-python
        '((:session . "py")
          (:kernel . "python3")
          (:async . "no"))))
#+end_src

* Documents
Use ~nov.el~ for reading ebooks
#+begin_src emacs-lisp :tangle packages.el
(package! nov)
#+end_src
#+begin_src emacs-lisp
(use-package nov
  :mode ("\\.epub\\'" . nov-mode))
#+end_src
* Email

I don't like the inbuilt ~notmuch~ Doom module, so I'm effectively implementing it myself
#+begin_src emacs-lisp :tangle packages.el
(package! notmuch)
#+end_src
#+begin_src emacs-lisp
(use-package! notmuch
  :defer t
  :init
  <<notmuch-init>>
  :config
  <<notmuch-config>>
  )
#+end_src

Ensure that linking to ~notmuch~ emails is enabled in ~org~
#+begin_src emacs-lisp :tangle no :noweb-ref notmuch-init
(after! org
  (add-to-list 'org-modules 'ol-notmuch))
#+end_src

Enable the completion backend in message mode so that email addresses are auto-completed
#+begin_src emacs-lisp :tangle no :noweb-ref notmuch-config
(set-company-backend! 'notmuch-message-mode
  '(notmuch-company :with company-ispell company-yasnippet))
#+end_src

Make the hello window a popup
#+begin_src emacs-lisp :tangle no :noweb-ref notmuch-config
(set-popup-rule! "^\\*notmuch" :ignore t)
#+end_src

Hide the notmuch logo
#+begin_src emacs-lisp :tangle no :noweb-ref notmuch-config
(setq notmuch-show-logo nil)
#+end_src

Hide headers by default
#+begin_src emacs-lisp :tangle no :noweb-ref notmuch-config
(setq notmuch-message-headers-visible nil)
#+end_src

Kill message buffers when sent
#+begin_src emacs-lisp :tangle no :noweb-ref notmuch-config
(setq message-kill-buffer-on-exit t)
#+end_src

Send mail with ~sendmail~
#+begin_src emacs-lisp :tangle no :noweb-ref notmuch-config
(setq message-send-mail-function 'message-send-mail-with-sendmail)
(setq send-mail-function 'sendmail-send-it)
#+end_src

Sort by new
#+begin_src emacs-lisp :tangle no :noweb-ref notmuch-config
(setq notmuch-search-oldest-first nil)
#+end_src

Fix width of columns in search results
#+begin_src emacs-lisp :tangle no :noweb-ref notmuch-config
(setq notmuch-search-result-format
      '(("date" . "%12s ")
        ("count" . "%-7s ")
        ("authors" . "%-30s ")
        ("subject" . "%-72s ")
        ("tags" . "(%s)")))
#+end_src

Make unread emails specially
#+begin_src emacs-lisp :tangle no :noweb-ref notmuch-config
(setq notmuch-tag-formats
      '(("unread" (propertize tag 'face 'notmuch-tag-unread))))
#+end_src

Set up the sections in the main hellow window
#+begin_src emacs-lisp :tangle no :noweb-ref notmuch-config
(setq notmuch-hello-sections
      '(notmuch-hello-insert-header
        notmuch-hello-insert-saved-searches
        notmuch-hello-insert-recent-searches
        notmuch-hello-insert-alltags))
#+end_src

Setup saved searches. I remove the unread search because it is irrelevant for me (and broken)
#+begin_src emacs-lisp :tangle no :noweb-ref notmuch-config
(setq notmuch-saved-searches
      '((:name "inbox"   :query "tag:inbox not tag:trash" :key "i")
        (:name "sent"    :query "tag:sent"                :key "s")
        (:name "drafts"  :query "tag:draft"               :key "d")
        (:name "all"     :query "*"                       :key "a")))
#+end_src

Ensure that send mail goes into the correct folder.
#+begin_src emacs-lisp :tangle no :noweb-ref notmuch-config
(setq notmuch-maildir-use-notmuch-insert nil)
(setq notmuch-fcc-dirs '(("tim@tquelch.com" . "personal/Sent Items")
                         ("tim@quelch.name" . "oldpersonal/[Gmail].Sent Mail")
                         ("t.quelch@qut.edu.au" . "qutstaff/Sent Items")
                         ("timothy.quelch@connect.qut.edu.au" . "qutstudent/Sent Items")
                         ("tim.quelch@student.unimelb.edu.au" . "uom/[Gmail].Sent Mail")))
#+end_src

Ensure that sent mail is sent from the correct address. i.e. the one in the header of the message
#+begin_src emacs-lisp :tangle no :noweb-ref notmuch-config
(setq mail-envelope-from 'header
      mail-specify-envelope-from 'header
      message-sendmail-envelope-from 'header)
#+end_src

Change the viewer for HTML email to GNUS w3m. It seems to be the best, but idk
#+begin_src emacs-lisp :tangle no :noweb-ref notmuch-config
(setq mm-text-html-renderer 'gnus-w3m)
#+end_src

Allow capturing of email in ~notmuch~
#+begin_src emacs-lisp :tangle no :noweb-ref notmuch-config
(defun tq/org-capture-email ()
  (interactive)
  (let ((org-capture-templates '(("e" "email"
                                  entry (file org-default-notes-file)
                                  "* TODO Reply: %a :email:"
                                  :immediate-finish t))))
    (org-capture nil "e")))

(map! :map notmuch-show-mode-map
      :nv "C" #'tq/org-capture-email)
#+end_src

Use =org-mime= to send HTML email
#+begin_src emacs-lisp :tangle packages.el
(package! org-mime)
#+end_src
#+begin_src emacs-lisp
(use-package! org-mime
  :commands (org-mime-htmlize
             org-mime-edit-mail-in-org-mode
             org-mime-revert-to-plain-text-mail)
  :config
  (setq org-mime-library 'mml))
#+end_src

Use ~helm-notmuch~ for searching email from helm.
#+begin_src emacs-lisp :tangle packages.el
(package! helm-notmuch)
#+end_src
#+begin_src emacs-lisp
(use-package! helm-notmuch
  :commands helm-notmuch
  :after notmuch)
(map! :leader :prefix "s"
      "n" 'helm-notmuch)
#+end_src

* Languages
Some extra packages and languages that are not included by doom modules by default

** Systemd unit files
#+begin_src emacs-lisp :tangle packages.el
(package! systemd)
#+end_src
#+begin_src emacs-lisp
(use-package systemd
  :defer t)
#+end_src

** Docker compose
#+begin_src emacs-lisp :tangle packages.el
(package! docker-compose-mode)
#+end_src
#+begin_src emacs-lisp
(use-package docker-compose-mode
  :defer t)
#+end_src
