#+property: header-args :results silent :tangle config.el :noweb yes

* Doom modules
:PROPERTIES:
:header-args: :tangle no :results silent :noweb-ref doom-modules
:END:

All my doom modules appear in the following sections
#+begin_src emacs-lisp :tangle init.el :noweb yes :noweb-ref no
(doom!
 <<doom-modules>>
 )
#+end_src

** Completion
I'm using company as my inline completion framework, and helm as my navigation/completion/UI completion framework
#+begin_src emacs-lisp
:completion
(company +childframe)
(helm +fuzzy)
#+end_src

** UI
I enable various UI improvements and such here
#+begin_src emacs-lisp
:ui
doom
modeline
nav-flash
ophints
(popup +defaults)
treemacs
vc-gutter
vi-tilde-fringe
window-select
#+end_src

** Editor
I use evil keybindings everywhere. I also want to enable snippets and code formatting
#+begin_src emacs-lisp
:editor
(evil +everywhere)
format
snippets
#+end_src

** Emacs
Improve ~dired~, version-control, and parenthesis behaviour
#+begin_src emacs-lisp
:emacs
(dired +icons)
electric
vc
undo
#+end_src

** Terminal
~vterm~ is the best term
#+begin_src emacs-lisp
:term
vterm
#+end_src

** Checkers
Enable syntax and spell checkers
#+begin_src emacs-lisp
:checkers
syntax
spell
#+end_src

** Tools
Set up a bunch of extra functionality in emacs
#+begin_src emacs-lisp
:tools
(eval +overlay)                         ; evaluation
docker                                  ; docker
lookup                                  ; lookup of definitions/docs
(lsp +peek)                             ; enable language server
(magit +forge)                          ; git wizardry
pdf                                     ; pdf viewing and annotation
#+end_src

** Languages
Enable lots of programming language integrations
#+begin_src emacs-lisp
:lang
(cc +lsp)
emacs-lisp
data
json
latex
markdown
(org +jupyter +noter +journal +present)
(python +lsp +pyenv)
(julia +lsp)
(sh +fish)
#+end_src

** App
#+begin_src emacs-lisp
:app
calendar
#+end_src

** Config
Enable bindings and also tell Doom that I'm using a literate config
#+begin_src emacs-lisp
:config
literate
(default +bindings +smartparens)
#+end_src
* Environment

By default doom blacklists ~SSH_AUTH_SOCK~ and ~SSH_AUTH_PID~ variables, which means ssh agents don't work. This whitelists them in =init.el=
#+begin_src emacs-lisp :tangle init.el
(when noninteractive
  (add-to-list 'doom-env-whitelist "^SSH_"))
#+end_src

* Personalisation
Setup name and email
#+begin_src emacs-lisp
(setq user-full-name "Tim Quelch"
      user-mail-address "tim@quelch.name")
#+end_src

Load my secrets (API keys, email configs etc.)
#+begin_src emacs-lisp
(defvar tq/secrets-loaded (load (concat doom-private-dir "my-secrets") t))
#+end_src

* UI
Use some nice fonts
#+begin_src emacs-lisp
(setq doom-font (font-spec :family "Iosevka" :size 18)
      doom-variable-pitch-font (font-spec :family "DejaVu Sans"))
#+end_src

Set the theme
#+begin_src emacs-lisp
(setq doom-one-brighter-comments t
      doom-one-comment-bg nil
      doom-theme 'doom-one)
#+end_src

Display line numbers
#+begin_src emacs-lisp
(setq display-line-numbers-type t)
#+end_src

Set up ~fill-column~ to be wider by default
#+begin_src emacs-lisp
(setq-default fill-column 100)
#+end_src

Increase the amount of context lines when scrolling full screen-fulls (default is 2)
#+begin_src emacs-lisp
(setq next-screen-context-lines 8)
#+end_src

Wrap lines at fill column when using ~visual-line-mode~
#+begin_src emacs-lisp :tangle packages.el
(package! visual-fill-column :pin "64d38bc1c00953be05c193c01332a633be67aac2")
#+end_src
#+begin_src emacs-lisp
(use-package visual-fill-column
  :hook (visual-line-mode . visual-fill-column-mode)
  :config
  (setq-default split-window-preferred-function
                'visual-fill-column-split-window-sensibly))
#+end_src

Set up ~mixed-pitch-mode~ in text modes. Proportional fonts are much nicer to read, but I still want fixed pitch in code blocks
#+begin_src emacs-lisp :tangle packages.el
(package! mixed-pitch :pin "d305108f9520e196b533f05d1dcc284cf535faaf")
#+end_src
#+begin_src emacs-lisp
(use-package mixed-pitch
  :hook (text-mode . mixed-pitch-mode)
  :config
  (pushnew! mixed-pitch-fixed-pitch-faces
            'org-date
            'org-special-keyword
            'org-property-value
            'org-drawer
            'org-ref-cite-face
            'org-tag
            'org-todo-keyword-todo
            'org-todo-keyword-habt
            'org-todo-keyword-done
            'org-todo-keyword-wait
            'org-todo-keyword-kill
            'org-todo-keyword-outd
            'org-todo
            'org-done
            'font-lock-comment-face
            'line-number
            'line-number-current-line))
#+end_src

Ensure ~dired-omit-mode~ is not started with dired. It hides some files transparently and has caused lots of confusion on my part.
#+begin_src emacs-lisp
(after! dired
  (remove-hook 'dired-mode-hook 'dired-omit-mode))
#+end_src

* Helm
Use heading of helm as input line
#+begin_src emacs-lisp
(after! helm
  (setq helm-echo-input-in-header-line t)
  (add-hook 'helm-minibuffer-set-up-hook 'helm-hide-minibuffer-maybe))
#+end_src

Increase size of helm buffers
#+begin_src emacs-lisp
(after! helm
  (set-popup-rule! "^\\*helm" :size 0.3))
#+end_src

Increase width of buffer name field in buffer list
#+begin_src emacs-lisp
(after! helm
  (setq helm-buffer-max-length nil))
#+end_src

Override Doom's search buffer with swiper-helm. See [[https://github.com/hlissner/doom-emacs/pull/3969][this PR]].
#+begin_src emacs-lisp
(defadvice! tq/default-search-buffer ()
  :override #'+default/search-buffer
  (interactive)
  (call-interactively
   (if (featurep! :completion helm)
       #'swiper-helm
     (if (region-active-p)
         #'swiper-isearch-thing-at-point
       #'swiper-isearch))))
#+end_src
* Company
Reduce prefix length and delay. I want completion /fast/. THis may cause performance issues
#+begin_src emacs-lisp
(after! company
  (setq company-idle-delay 0.3
        company-minimum-prefix-length 0))
#+end_src

Setup the default backends. By default doom includes ~company-dabbrev~ which adds too much noise. Yasnippet backed is also annoying and not included
#+begin_src emacs-lisp
(set-company-backend! '(text-mode prog-mode conf-mode) 'company-capf)
#+end_src

* Editing
Enable the use of =C-u= as the universal argument again
#+begin_src emacs-lisp
(after! evil
  (setq! evil-want-C-u-delete nil
         evil-want-C-u-scroll nil))
#+end_src

Enable easy use of ~avy~
#+begin_src emacs-lisp
(map! "C-'" #'avy-goto-char)
#+end_src

Use better ~comment-diwm~
#+begin_src emacs-lisp :tangle packages.el
(package! comment-dwim-2 :pin "3dfdd58495c46a37708344a57c5c52beca6b2c1c")
#+end_src
#+begin_src emacs-lisp
(use-package! comment-dwim-2
  :bind ([remap comment-dwim] . comment-dwim-2)
  :config (setq cd2/region-command 'cd2/comment-or-uncomment-region))
#+end_src

Disable some extra packages that I don't really use
#+begin_src emacs-lisp :tangle packages.el
(disable-packages! evil-snipe evil-lion)
#+end_src

* Org and friends

** Base
#+begin_src emacs-lisp
(setq org-directory "~/documents/org/")
#+end_src

Set the org-agenda files to be the org directory. This includes all the files in the base directory, but no sub-directories.
#+begin_src emacs-lisp
(defvar org-agenda-files nil)
(add-to-list 'org-agenda-files org-directory)
#+end_src

#+begin_src emacs-lisp
(after! org
  <<org-configuration>>
  )
#+end_src

Setting up ~TODO~ states. ~WAITING~ and ~CANCELLED~ require messages when entering these states. I'm trying not to use the ~EMAIL~ state, but keeping it here for archive purposes.
#+begin_src emacs-lisp  :tangle no :noweb-ref org-configuration
(setq org-todo-keywords '((sequence "TODO(t)" "NEXT(n)" "WAITING(w@/!)" "|" "DONE(d)")
                          (sequence "EMAIL(e)" "|" "SENT(s)")
                          (sequence "|" "CANCELLED(c@/!)")
                          (sequence "|" "MOVED(m)")))
#+end_src

Ensure that sub-tasks must be completed before the parent task can be marked done
#+begin_src emacs-lisp :tangle no :noweb-ref org-configuration
(setq org-enforce-todo-dependencies t)
#+end_src

Log the time when tasks are completed
#+begin_src emacs-lisp :tangle no :noweb-ref org-configuration
(setq org-log-done 'time)
#+end_src

Setup refile targets. Targets include the current file and all agenda files (files in the org directory) up to 9 levels deep in the hierarchy. Only in-progress tasks are allowed as refile targets
#+begin_src emacs-lisp :tangle no :noweb-ref org-configuration
(setq org-refile-allow-creating-parent-nodes 'confirm)
(setq org-refile-targets '((nil :maxlevel . 9)
                           (org-agenda-files :maxlevel . 9)))

(defun tq/verify-refile-target ()
  "Exclude done todo states from refile targets"
  (not (member (nth 2 (org-heading-components)) org-done-keywords)))
(setq org-refile-target-verify-function 'tq/verify-refile-target)
#+end_src

Use the outline path as the refile target. This can be completed in steps to work well with helm etc.
#+begin_src emacs-lisp :tangle no :noweb-ref org-configuration
(setq org-refile-use-outline-path t)
(setq org-outline-path-complete-in-steps nil)
#+end_src

Don't log when changing state with shift-arrows
#+begin_src emacs-lisp :tangle no :noweb-ref org-configuration
(setq org-treat-S-cursor-todo-selection-as-state-change nil)
#+end_src

Log state changes into drawers rather than under the items itself. This is also important for habits
#+begin_src emacs-lisp :tangle no :noweb-ref org-configuration
(setq org-log-into-drawer t)
#+end_src

Pressing return over links will follow the link
#+begin_src emacs-lisp :tangle no :noweb-ref org-configuration
(setq org-return-follows-link t)
#+end_src

Archive to subdirectory and use datetree
#+begin_src emacs-lisp
(after! org-archive
  (setq org-archive-location "archive/%s_archive::datetree/"))
#+end_src

Highlight \LaTeX within ~org~
#+begin_src emacs-lisp :tangle no :noweb-ref org-configuration
(setq org-highlight-latex-and-related '(native script entities))
#+end_src

No longer start with latex or inline images. This is often quite slow.
#+begin_src emacs-lisp :tangle no :noweb-ref org-configuration
(setq org-startup-with-latex-preview nil
      org-startup-with-inline-images nil)
#+end_src

Enable the use of org-ids for links to headlines. ~org-id-track-globally~ is on by default in doom, however this only updates the org id file when emacs exits, so I'm not sure if it will work very well for me using a daemoned emacs.
#+begin_src emacs-lisp :tangle no :noweb-ref org-configuration
(setq org-id-link-to-org-use-id 'create-if-interactive)
#+end_src

Remove empty clock lines, they achieve nothing.
#+begin_src emacs-lisp
(after! org-clock
  (setq org-clock-out-remove-zero-time-clocks t))
#+end_src

Turn on auto-revert mode in org mode files so that they automatically update when changed (e.g. by syncthing, dropbox etc.). Doom does not do this automatically, instead only auto-reverting the current buffers, which is fine for most cases except background buffers used for agendas and capture.
#+begin_src emacs-lisp :tangle no :noweb-ref org-configuration
(add-hook 'org-mode-hook 'auto-revert-mode)
#+end_src

Only use ~company-capf~ for org mode. Again: I hate ~dabbrev~
#+begin_src emacs-lisp :tangle no :noweb-ref org-configuration
(set-company-backend! 'org-mode 'company-capf)
#+end_src

Unmap keybind that I use for avy
#+begin_src emacs-lisp :tangle no :noweb-ref org-configuration
(map! :map org-mode-map "C-'" nil)
#+end_src

Editing around links is a real pain. Often you are typing thinking you are outsid ethe link but it ends up adding to the description. Below are some simple functions to quickly exit the link
#+begin_src emacs-lisp :tangle no :noweb-ref org-configuration
(defun tq/org-exit-link-forward ()
  "Jump just outside a link forward"
  (interactive)
  (when (org-in-regexp org-link-any-re)
    (goto-char (match-end 0))
    (insert " ")))

(defun tq/org-exit-link-backward ()
  "Jump just outside a link backward"
  (interactive)
  (when (org-in-regexp org-link-any-re)
    (goto-char (match-beginning 0))
    (save-excursion (insert " "))))

(map! :map (evil-org-mode-map org-mode-map)
      :ni "C-k" #'tq/org-exit-link-forward
      :ni "C-j" #'tq/org-exit-link-backward)
#+end_src

Add simple keybinding to toggle latex fragments in org mode
#+begin_src emacs-lisp :tangle no :noweb-ref org-configuration
(map! :map evil-org-mode-map
      :n "zf" #'org-toggle-latex-fragment)
#+end_src

Disable some of the extra things that Doom enables
#+begin_src emacs-lisp :tangle packages.el
(disable-packages! org-superstar org-tree-slide)
#+end_src

** Agenda

I use ~org-super-agenda~ to group tasks in agenda
#+begin_src emacs-lisp emacs-lisp :tangle packages.el
(package! org-super-agenda :pin "3264255989021b8563ea42b5d26acbc2a024f14d")
#+end_src
#+begin_src emacs-lisp
(use-package! org-super-agenda
  :hook (org-agenda-mode . org-super-agenda-mode))

(after! (org-agenda org-super-agenda)
  (setq! org-super-agenda-header-map (make-sparse-keymap)))
#+end_src

Map agenda to a more convenient binding
#+begin_src emacs-lisp
(map! :leader "a" #'org-agenda)
#+end_src

Next I want to configure the agenda behaviour
#+begin_src emacs-lisp
(after! org-agenda
  <<org-agenda-configuration>>
  <<org-agenda-filters>>
  <<org-agenda-views>>
  )
#+end_src

When opening an item from the agenda, ensure the whole tree (parents and siblings) is visible
#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda-configuration
(add-hook 'org-agenda-after-show-hook 'org-reveal)
#+end_src

Don't dim blocked tasks (i.e. projects)
#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda-configuration
(setq org-agenda-dim-blocked-tasks nil)
#+end_src

Remove the 'category' header from the agenda. Because I only really use one main agenda file, this was the same for all the values in the agenda. Removing it gives me some more horizontal space in the agenda view.
#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda-configuration
(setq org-agenda-prefix-format '((agenda . " %i %?-12t% s")
                                 (todo . " %i ")
                                 (tags . " %i ")
                                 (search . " %i ")))
#+end_src

I also remap movement keys to move between agenda items rather than between lines, as this is what you want to do the vast majority of the time.
#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda-configuration
(map! :map org-agenda-mode-map
      [remap org-agenda-next-line] #'org-agenda-next-item
      [remap org-agenda-previous-line] #'org-agenda-previous-item)
#+end_src

Set up some other useful bindings
#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda-configuration
(map! :map org-agenda-mode-map
      :m "w" #'org-save-all-org-buffers
      :m "f" #'org-agenda-follow-mode)
#+end_src

Enable habits
#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda-configuration
(add-to-list 'org-modules 'org-habit)
#+end_src

*** Agenda views
:PROPERTIES:
:header-args: :noweb-ref org-agenda-views :tangle no
:END:

Setup the groups that appear in the agenda views.

#+begin_src emacs-lisp
(setq org-super-agenda-groups
      '((:name "Waiting"
         :todo "WAITING"
         :order 103)
        (:name "Emails"
         :tag "email"
         :order 3)
        (:name "Housework"
         :tag "home"
         :order 100)
        (:name "To read"
         :tag "toread"
         :order 4)
        (:name "To Write"
         :tag "towrite"
         :order 5)
        (:name "Work"
         :tag ("work" "phd")
         :order 6)
        (:name "Habits"
         :habit t
         :order 101)
        (:name "Configuration"
         :tag "config"
         :order 102)))
#+end_src

I want to see emails high up, because usually they are pretty quick to do. Housework and habits I don't want to see until lower in the agenda, because they are usually low priority. Configuration to do in emacs or my OS is incredibly low priority so I want to see that last.

Any items that do not fall in one of these filter categories goes in an automatic 'Other Items' section which has an order of 99 (so will appear before anything with an order >99)


In my PhD view, I want do discard anything hobby or housework related. I strip out these items in the super agenda groups.
#+begin_src emacs-lisp
(defvar tq/phd-org-super-agenda-groups
  (cons '(:discard (:tag ("home" "hobby"))) org-super-agenda-groups))
#+end_src

Below I'm setting up my main agenda view as well as a projects view
#+begin_src emacs-lisp :noweb yes
(setq org-agenda-custom-commands
      '(("j" "Super agenda" (
                             <<agenda-custom-commands>>
                             ))
        ("p" "Projects" (
                         <<agenda-projects-custom-commands>>
                         ))
        ("w" "PhD" (
                    <<agenda-phd-custom-commands>>
                    ))))
#+end_src

**** Super agenda
:PROPERTIES:
:header-args: :noweb-ref agenda-custom-commands :tangle no :results silent
:END:
The first view is today's agenda, for tasks scheduled today (or in the past) or with deadlines coming up. I include at schedule at the top
#+begin_src emacs-lisp
(agenda "" ((org-super-agenda-groups
             (cons '(:name "Schedule" :time-grid t) org-super-agenda-groups))
            (org-agenda-span 'day)
            (org-agenda-start-day)))
#+end_src

The next section is the Inbox. These are items that I have captured quickly and need to be refiled into my main agenda file.
#+begin_src emacs-lisp
(tags "inbox"
      ((org-agenda-overriding-header "Inbox")
       (orgs-tag-match-list-sublevels nil)))
#+end_src

This section shows projects which are stuck. I define projects as todo items with sub todo items. A stuck project is a project where none of the sub-todos has a NEXT keyword. These are projects where I don't have a task to go onto next. I want to see these because I need to go into these projects and evaluate what tasks I can begin next
#+begin_src emacs-lisp
(todo "" ((org-agenda-overriding-header "Stuck projects")
          (org-agenda-skip-function 'tq/skip-all-but-stuck-projects)))

#+end_src

This section shows tasks and projects which are available to be completed (e.g. they are standalone tasks or sub-tasks with a NEXT keyword) but are unscheduled. I want to see these because I need to schedule them to complete sometime.
#+begin_src emacs-lisp
(todo "" ((org-agenda-overriding-header "Unscheduled available todos")
          (org-agenda-skip-function 'tq/skip-all-but-available-unscheduled-todos)))
#+end_src

**** Projects view
:PROPERTIES:
:header-args: :noweb-ref agenda-projects-custom-commands :tangle no :results silent
:END:
The project view is for viewing all of my current projects (including sub-projects for now)
#+begin_src emacs-lisp
(todo "" ((org-agenda-skip-function #'tq/skip-all-but-projects)))
#+end_src

**** PhD view
:PROPERTIES:
:header-args: :noweb-ref agenda-phd-custom-commands :tangle no :results silent
:END:
This view is the one that I look at during my 'work' day. The first view is the time grid which includes everything scheduled for a specific time during the day. I need this to include everything as I might sometimes have a personal or home task scheduled during the day.
#+begin_src emacs-lisp
(agenda "" ((org-super-agenda-groups '((:name "Schedule" :time-grid t)
                                       (:discard (:anything t))))
            (org-agenda-span 'day)
            (org-agenda-start-day)))
#+end_src

Next It will include the agenda for the current day, discarding any 'home' tasks.
#+begin_src emacs-lisp
(agenda "" ((org-super-agenda-groups (cons '(:discard (:time-grid t))
                                           tq/phd-org-super-agenda-groups ))
            (org-agenda-span 'day)
            (org-agenda-start-day)))
#+end_src

The following sections are pretty much the same as the super agenda, but again ignoring the home tasks
#+begin_src emacs-lisp
(tags "inbox"
      ((org-super-agenda-groups tq/phd-org-super-agenda-groups)
       (org-agenda-overriding-header "Inbox")
       (orgs-tag-match-list-sublevels nil)))
#+end_src

#+begin_src emacs-lisp
(todo "" ((org-super-agenda-groups tq/phd-org-super-agenda-groups)
          (org-agenda-overriding-header "Stuck projects")
          (org-agenda-skip-function 'tq/skip-all-but-stuck-projects)))

#+end_src

#+begin_src emacs-lisp
(todo "" ((org-super-agenda-groups tq/phd-org-super-agenda-groups)
          (org-agenda-overriding-header "Unscheduled available todos")
          (org-agenda-skip-function 'tq/skip-all-but-available-unscheduled-todos)))
#+end_src

*** Agenda filters
:PROPERTIES:
:header-args: :noweb-ref org-agenda-filters :tangle no :results silent
:END:

Functions that I use to filter the agenda
#+begin_src emacs-lisp
(defun tq/is-todo-p ()
  (member (nth 2 (org-heading-components)) org-todo-keywords-1))

(defun tq/has-subtodo-p ()
  (save-restriction
    (widen)
    (let ((has-subtodo)
          (subtree-end (save-excursion (org-end-of-subtree t))))
      (save-excursion
        (forward-line 1)
        (while (and (not has-subtodo)
                    (< (point) subtree-end)
                    (re-search-forward org-heading-regexp subtree-end t))
          (when (tq/is-todo-p)
            (setq has-subtodo t))))
      has-subtodo)))

(defun tq/is-project-p ()
  "Is a project. i.e. A todo (with a todo keyword) that has at least one subtodo (with a todo keyword)"
  (and (tq/is-todo-p) (tq/has-subtodo-p)))

(defun tq/is-task-p ()
  "Is a task. i.e. A todo (with a todo keyword) that has no subtodos (with a todo keyword)"
  (and (tq/is-todo-p) (not (tq/has-subtodo-p))))

(defun tq/is-subtodo-p ()
  "Is todo (either a task or a project) that is part of a project"
  (save-restriction
    (widen)
    (let ((is-subtodo)
          (is-a-todo (tq/is-todo-p)))
      (when is-a-todo
        (save-excursion
          (while (and (not is-subtodo)
                      (org-up-heading-safe))
            (when (tq/is-todo-p)
              (setq is-subtodo t)))))
      (and is-a-todo is-subtodo))))

(defun tq/is-subproject-p ()
  "Is task that is part of a project"
  (and (tq/is-subtodo-p) (tq/is-project-p)))

(defun tq/is-subtask-p ()
  "Is task that is part of a project"
  (and (tq/is-subtodo-p) (tq/is-task-p)))

(defun tq/is-standalone-project-p ()
  "Is project that is not part of a project"
  (and (not (tq/is-subtodo-p)) (tq/is-project-p)))

(defun tq/is-standalone-task-p ()
  "Is task that is not part of a project"
  (and (not (tq/is-subtodo-p)) (tq/is-task-p)))

(defvar tq/next-todo-keyword "NEXT"
  "The todo keyword indicating the next task in a project. Any project without at least one subtask with this keyword is considered stuck")

(defun tq/is-stuck-project-p ()
  "Is a project that is stuck"
  (when (tq/is-project-p)
    (let ((subtree-end (save-excursion (org-end-of-subtree t)))
          (next-regexp (concat org-outline-regexp-bol tq/next-todo-keyword " ")))
      (forward-line 1)
      (not (re-search-forward next-regexp subtree-end t)))))

(defun tq/skip-all-but-stuck-projects ()
  "Skip trees that are not stuck projects"
  (save-restriction
    (widen)
    (unless (tq/is-stuck-project-p)
      (save-excursion (or (outline-next-heading) (point-max))))))

(defun tq/skip-all-but-available-unscheduled-todos ()
  "Skip todos that are unavailable or available but already scheduled. Available todos are standalone tasks or NEXT tasks"
  (save-restriction
    (widen)
    (unless (and (or (tq/is-standalone-task-p)
                     (string-equal (org-get-todo-state) tq/next-todo-keyword))
                 (not (org-get-scheduled-time nil)))
      (save-excursion (or (outline-next-heading) (point-max))))))

(defun tq/skip-all-but-projects ()
  "Skip trees that are not projects"
  (save-restriction
    (widen)
    (unless (tq/is-project-p)
      (save-excursion (or (outline-next-heading) (point-max))))))
#+end_src

** Capture

Bind capture to something more convenient
#+begin_src emacs-lisp
(map! :leader "j" #'org-capture)
#+end_src

Configure my capture templates. These need to go in this advice because doom loads these on a hook.
#+begin_src emacs-lisp
(defadvice! tq/setup-capture-templates ()
  :after #'+org-init-capture-defaults-h
  (setq org-default-notes-file (expand-file-name "inbox.org" org-directory))

  (setq org-capture-templates
        '(("t" "todo" entry (file org-default-notes-file)
           "* TODO %?")
          ("n" "note" entry (function (lambda ()
                                        (org-journal-new-entry t)
                                        (while (org-up-heading-safe))))
           "* %(format-time-string org-journal-time-format)%?\n%i")
          ("a" "appointment" entry (file org-default-notes-file)
           "* %?"))))
#+end_src

** Referencing

Define my default bibliography file (generated and maintained by Zotero/BBL)
#+begin_src emacs-lisp
(defvar tq/bibliography-file "~/documents/library.bib")
#+end_src

I'm using ~org-ref~ to manage citations within org-mode. This might soon be replaced by native citation support though :o
#+begin_src emacs-lisp :tangle packages.el
(package! org-ref :pin "9dbf7cf2069acec47a8e5d027da0a253dff024ca")
#+end_src
#+begin_src emacs-lisp
(use-package! org-ref
  :after org
  :defer-incrementally t
  :init
  (setq! org-ref-default-bibliography (list tq/bibliography-file)
         org-ref-default-citation-link "autocite"
         org-ref-get-pdf-filename-function (lambda (key) (car (bibtex-completion-find-pdf key)))))
#+end_src

Use ~helm-bibtex~ as the main way of dealing with bibliographies
#+begin_src emacs-lisp :tangle packages.el
(package! helm-bibtex :pin "12f8809aac3a13dd11a1c664a13f789005f7a199")
#+end_src
#+begin_src emacs-lisp
(use-package! helm-bibtex
  :after org-ref
  :config
  (setq! bibtex-completion-pdf-field "file"
         bibtex-completion-bibliography tq/bibliography-file
         helm-bibtex-full-frame nil)

  (setq! bibtex-completion-display-formats
         '((t . "${author:36} ${title:*} ${year:4} ${=has-pdf=:1}${=has-note=:1} ${=type=:20}")))

  (defadvice! tq/helm-bibtex-window-width ()
    "Override the window width getter to manually reduce the width"
    :override
    #'helm-bibtex-window-width
    (- (window-body-width) 8))

  (map! :leader :prefix "s"
        "c" #'helm-bibtex))
#+end_src

** Exporting
#+begin_src emacs-lisp
(use-package ox-extra
  :after org
  :config
  (ox-extras-activate '(ignore-headlines)))
#+end_src

#+begin_src emacs-lisp
(use-package ox-latex
  :after org
  :config
  (add-to-list 'org-latex-classes '("a4article"
                                    "\\documentclass[11pt,a4paper]{article}"
                                    ("\\section{%s}" . "\\section*{%s}")
                                    ("\\subsection{%s}" . "\\subsection*{%s}")
                                    ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                                    ("\\paragraph{%s}" . "\\paragraph*{%s}")
                                    ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
  (setq org-latex-default-class "a4article")
  (setq org-latex-packages-alist '(("titletoc, title" "appendix" nil) ; Setup appendices
                                   ("margin=25mm" "geometry")         ; Setup margins
                                   ("" "tocbibind" nil)  ; Put bibliography in TOC
                                   ("" "pdflscape" nil)  ; Allow landscape pages
                                   ("" "pdfpages" nil)   ; Allow inclusion of pdfs
                                   ("" "svg" nil)        ; Allow SVG images (req. inkscape?)
                                   ("" "subcaption" nil) ; Allow subcaptions
                                   ("" "listings" nil)   ; Source code listings
                                   ("" "color" nil)      ; Color in source code listings
                                   ("binary-units" "siunitx" t)))     ; SI units

  (setq org-latex-pdf-process (list "latexmk -shell-escape -bibtex -f -pdf %f"))

  (setq org-latex-listings t)                                         ; Turn on source code inclusion
  (setq org-latex-listings-options '(("basicstyle" "\\linespread{0.85}\\ttfamily")
                                     ("numbers" "left")
                                     ("numberstyle" "\\tiny")
                                     ("frame" "tb")
                                     ("tabsize" "4")
                                     ("columns" "fixed")
                                     ("showstringspaces" "false")
                                     ("showtabs" "false")
                                     ("keepspaces" "true")
                                     ("commentstyle" "\\color{red}")
                                     ("keywordstyle" "\\color{blue}")
                                     ("breaklines" "true"))))
#+end_src

** Notetaking

*** Roam

Setup ~org-roam~, ~org-roam-bibtex~, and ~org-roam-server~ to track source
#+begin_src emacs-lisp :tangle packages.el
(package! org-roam
  :recipe (:host github :repo "org-roam/org-roam")
  :pin "0cce9d116580665d9eb9284d3317ae1beda56bc1")
(package! org-roam-bibtex
  :recipe (:host github :repo "org-roam/org-roam-bibtex")
  :pin "0cce9d116580665d9eb9284d3317ae1beda56bc1")
;; (package! org-roam-server :recipe (:host github :repo "org-roam/org-roam-server"))
#+end_src

Set up more useful keybindings to use and access ~org-roam~
#+begin_src emacs-lisp
(map! :leader
      :prefix "n"
      "f" #'org-roam-find-file
      :map org-roam-mode-map
      "i" #'org-roam-insert
      "g" #'org-roam-graph
      "r" #'org-roam)
#+end_src

I want to roll my own ~org-roam~ config rather than use doom's module.
#+begin_src emacs-lisp
(use-package! org-roam
  :hook (org-load . org-roam-mode)
  :hook (org-roam-backlinks-mode . turn-on-visual-line-mode)
  :init
  <<org-roam-init>>
  :config
  <<org-roam-config>>
  )
#+end_src

Set directory for my ~org-roam~ notes
#+begin_src emacs-lisp :tangle no :noweb-ref org-roam-init
(setq org-roam-directory (concat (file-name-as-directory org-directory) "notes"))
#+end_src

Put the database in the doom cache directory, rather than stored with the notes
#+begin_src emacs-lisp :tangle no :noweb-ref org-roam-init
(setq org-roam-db-location (concat doom-cache-dir "org-roam.db"))
#+end_src

Turn off verbosity. I don't like the messages
#+begin_src emacs-lisp :tangle no :noweb-ref org-roam-config
(setq org-roam-verbose nil)
#+end_src

Set up capture template. It includes a TODO item to write about the note. I have it set to finish immediately, as I don't really like editing them instantly.
#+begin_src emacs-lisp :tangle no :noweb-ref org-roam-config
(setq org-roam-capture-templates
      '(("d" "default" plain (function org-roam-capture--get-point)
         "%?"
         :file-name "%<%Y%m%d%H%M%S>-${slug}"
         :head "#+title: ${title}\n:preamble:\n#+setupfile: setup.org\n:end:\n\n\n\n* TODO Write about '${title}' :towrite:"
         :unnarrowed t
         :immediate-finish t)))
#+end_src

Ensure tags come from both the directory and the ~roam_tag~ file property. The default is just the property
#+begin_src emacs-lisp :tangle no :noweb-ref org-roam-config
(setq org-roam-tag-sources '(prop all-directories))
#+end_src

Exclude daily notes from the graph
#+begin_src emacs-lisp :tangle no :noweb-ref org-roam-config
(setq org-roam-graph-exclude-matcher '("daily/"))
#+end_src

Set up an agenda view for nearby notes
#+begin_src emacs-lisp
(defun tq/org-agenda-nearby-notes (&optional distance)
  (interactive "P")
  (let ((org-agenda-files (org-roam-db--links-with-max-distance
                           buffer-file-name (or distance 3)))
        (org-agenda-custom-commands '(("e" "" ((alltodo ""))))))
    (org-agenda nil "e")))

(map! :leader :prefix "n" :desc "Agenda nearby" "a" #'tq/org-agenda-nearby-notes)
#+end_src

Set up a graph view where citation links are excluded
#+begin_src emacs-lisp
(defun tq/org-roam-graph-without-cites (&optional arg)
  (interactive "P")
  (let ((org-roam-graph-exclude-matcher (cons "lit/" org-roam-graph-exclude-matcher)))
    (org-roam-graph-show arg)))

(map! :leader :prefix "n" "G" #'tq/org-roam-graph-without-cites)
#+end_src

Change org-roam buffer names to be named after the title
#+begin_src emacs-lisp :tangle no :noweb-ref org-roam-config
(add-hook! 'org-roam-file-setup-hook
  (when-let ((title (org-roam-db--get-titles (buffer-file-name))))
    (rename-buffer title)))
#+end_src

Setup case-insensitive completion in ~org-roam~ files
#+begin_src emacs-lisp :tangle no :noweb-ref org-roam-config
(add-hook! 'org-roam-file-setup-hook
  (setq-local completion-ignore-case t))
#+end_src

+Also set up completion to trigger everywhere, not just on link start.+ Disable completion anywhere, it isn't working as I would like right now.
#+begin_src emacs-lisp :tangle no :noweb-ref org-roam-config
(setq org-roam-completion-everywhere nil)
#+end_src

Do not update links in other files when changing titles. Links are often context dependant and it doesn't make sense to change the it in other files.
#+begin_src emacs-lisp :tangle no :noweb-ref org-roam-config
(remove-hook 'org-roam-title-change-hook
             'org-roam--update-links-on-title-change)
#+end_src

*** Journal
I want to use ~org-journal~ as the way to capture and navigate my daily and fleeting notes
#+begin_src emacs-lisp
(after! org-journal
  <<org-journal-configuration>>
  )
#+end_src

Set the journal directory to be inside my roam directory
#+begin_src emacs-lisp :tangle no :noweb-ref org-journal-configuration
(setq org-journal-dir (expand-file-name "daily/" org-roam-directory))
#+end_src

I want to use a weekly journal file. This should make weekly reviews somewhat easier and will result in fewer overall files
#+begin_src emacs-lisp :tangle no :noweb-ref org-journal-configuration
(setq org-journal-file-type 'weekly)
#+end_src

Setup file header. This will likely put the date on the first one that I actually create the entry, and not only Monday. This is ok though.
#+begin_src emacs-lisp :tangle no :noweb-ref org-journal-configuration
(setq org-journal-file-header "#+title: Weekly journal for %F")
#+end_src

Set file format to use a .org extension. No idea why this isn't the default
#+begin_src emacs-lisp :tangle no :noweb-ref org-journal-configuration
(setq org-journal-file-format "%Y-%m-%d.org")
#+end_src

Don't carryover any items
#+begin_src emacs-lisp :tangle no :noweb-ref org-journal-configuration
(setq org-journal-carryover-items nil)
#+end_src

Add more convenient mappings for journal access
#+begin_src emacs-lisp
(map! :leader :prefix "n"
      :desc "Journal entry"   "n" #'org-journal-new-entry
      :desc "Today's journal" "t" (cmd!! #'org-journal-new-entry t))
#+end_src

I often want to refile ~TODO~ items from journal or other org files into my inbox. This function copies the headline into my inbox, and creates bi-directional links on both headlines. It also marks the original headlines as the ~MOVED~ todo keyword.
#+begin_src emacs-lisp
(defun tq/refile-to-inbox ()
  (interactive)
  (let ((id (org-id-get-create)))
    (org-refile 3 nil (list org-default-notes-file org-default-notes-file nil nil))
    (org-edit-headline (concat "[[id:" id "][HERE]] " (nth 4 (org-heading-components))))
    (let ((new-id (org-id-get-create t)))
      (save-window-excursion
        (org-id-goto id)
        (org-set-property "ORIGIN" (concat "[[id:" new-id "]]")))))
  (let ((org-enforce-todo-dependencies nil))
   (org-map-entries (lambda () (org-todo "MOVED")) nil 'tree)))

(after! org
  (map! :map org-mode-map :localleader :prefix "r" "i" #'tq/refile-to-inbox))
#+end_src

*** Bibtex
Enable ~org-roam-bibtex~ and setup capture template
#+begin_src emacs-lisp
(use-package org-roam-bibtex
  :commands (org-roam-bibtex-insert-non-ref org-roam-bibtex-find-non-ref)
  :hook (org-roam-mode . org-roam-bibtex-mode)
  :config
  <<orb-configuration>>
  )
#+end_src

Set up literature notes template
#+begin_src emacs-lisp :tangle no :noweb-ref orb-configuration
(setq orb-templates
      `(("r" "ref" plain
         (function org-roam-capture--get-point)
         ""
         :file-name ,(concat (file-name-as-directory "lit") "%<%Y%m%d%H%M%S>-${slug}")
         :head "#+title: Notes on: ${title}\n#+roam_key: ${ref}\n:preamble:\n#+setupfile: ../setup.org\n:end:\n\n"
         :unnarrowed t
         :immediate-finish t)))
#+end_src

Set up orb note actions. I remove some of the options that I don't use or want here.
#+begin_src emacs-lisp
(use-package orb-note-actions
  :config
  (setq orb-note-actions-frontend 'helm)
  (setq orb-note-actions-default (--remove
                                  (eq (cdr it) #'bibtex-completion-add-pdf-to-library)
                                  orb-note-actions-default))
  (setq orb-note-actions-extra (--remove
                                  (eq (cdr it) #'orb-note-actions-scrap-pdf)
                                  orb-note-actions-extra)))
#+end_src

Add convenient keybinding for accessing note actions
#+begin_src emacs-lisp
(map! :leader :prefix "n"
      "b" #'orb-note-actions)
#+end_src

*** Noter
I don't like the configuration in Doom's ~org-noter~ module so I do it myself
#+begin_src emacs-lisp :tangle packages.el
(package! org-noter :pin "9ead81d42dd4dd5074782d239b2efddf9b8b7b3d")
#+end_src
#+begin_src emacs-lisp
(use-package org-noter
  :defer t
  :config
  (map! :map org-noter-doc-mode-map
        :leader :n "i" #'org-noter-insert-note))
#+end_src

Disable ~org-pdftools~ because it breaks ~org-noter~ in ~nov~ mode
#+begin_src emacs-lisp :tangle packages.el
(disable-packages! org-pdftools)
#+end_src

** Babel
I'm mostly happy with doom's configuration for ~jupyter~
#+begin_src emacs-lisp
(after! jupyter
  (setq org-babel-default-header-args:jupyter-python
        '((:session . "py")
          (:kernel . "python3")
          (:async . "no")))
  (setq org-babel-default-header-args:jupyter-julia
        '((:session . "jl")
          (:kernel . "julia-1.5")
          (:async . "no"))))
#+end_src

* Calendar

Define directory for calendars to go in
#+begin_src emacs-lisp
(defvar tq/cal-dir (concat org-directory "calendars/"))
#+end_src

I also want to add this to the list of org-agenda files that are used
#+begin_src emacs-lisp
(add-to-list 'org-agenda-files tq/cal-dir)
#+end_src

Configure calendars. These use some secret values that I do not commit to git (for obvious reasons). ~gcal-file-alist~ is an alist of the form ~'(("calendar-id" . "filename") ("id2" . "file2"))~. This will then put calendar entries in to =calendar/filename.org= and =calendar/file2.org=.
#+begin_src emacs-lisp
(after! org-gcal
  (when tq/secrets-loaded
    (setq org-gcal-client-id secret/gcal-client-id
          org-gcal-client-secret secret/gcal-client-secret
          org-gcal-fetch-file-alist
          (-map (lambda (entry)
                  (cons (car entry) (concat tq/cal-dir (cdr entry) ".org")))
                secret/gcal-file-alist))))
#+end_src

Run sync on idle timer
#+begin_src emacs-lisp
(after! org-gcal
  (run-with-idle-timer 600 t #'org-gcal-sync))
#+end_src

* Email
I don't like the inbuilt ~notmuch~ Doom module, so I'm effectively implementing it myself
#+begin_src emacs-lisp :tangle packages.el
(package! notmuch :pin "45193bab16c728ba892a5d45fc62ef59e2a6ef85")
#+end_src
#+begin_src emacs-lisp
(use-package! notmuch
  :defer t
  :commands (notmuch notmuch-mua-new-mail)
  :init
  <<notmuch-init>>
  :config
  <<notmuch-config>>
  )
#+end_src

Ensure that linking to ~notmuch~ emails is enabled in ~org~
#+begin_src emacs-lisp :tangle no :noweb-ref notmuch-init
(after! org
  (add-to-list 'org-modules 'ol-notmuch))
#+end_src

Add a nice keymap for accessing email
#+begin_src emacs-lisp :tangle no :noweb-ref notmuch-init
(map! :leader
      (:prefix ("e" . "email")
       :desc "Browse"         "e" (cmd! (notmuch) (widget-forward 4))
       :desc "New email"      "n" #'notmuch-mua-new-mail
       :desc "Saved searches" "j" #'notmuch-jump-search
       :desc "Search"         "s" #'helm-notmuch))

(map! :map doom-leader-search-map
      :desc "Search emails" "e" #'helm-notmuch)
#+end_src

Ensure that ~notmuch~ buffers are treated as real buffers
#+begin_src emacs-lisp :tangle no :noweb-ref notmuch-config
(defun tq/notmuch-buffer-p (buffer)
  (or (string-match-p "^\\*notmuch" (buffer-name buffer))
      (with-current-buffer buffer
        (equal major-mode 'notmuch-show-mode))))

(add-to-list 'doom-real-buffer-functions #'tq/notmuch-buffer-p)
#+end_src

Hide the ~notmuch~ logo
#+begin_src emacs-lisp :tangle no :noweb-ref notmuch-config
(setq notmuch-show-logo nil)
#+end_src

Show headers by default
#+begin_src emacs-lisp :tangle no :noweb-ref notmuch-config
(setq notmuch-message-headers-visible t)
#+end_src

Kill message buffers when sent
#+begin_src emacs-lisp :tangle no :noweb-ref notmuch-config
(setq message-kill-buffer-on-exit t)
#+end_src

Send mail with ~sendmail~
#+begin_src emacs-lisp :tangle no :noweb-ref notmuch-config
(setq message-send-mail-function 'message-send-mail-with-sendmail)
(setq send-mail-function 'sendmail-send-it)
#+end_src

Sort by new
#+begin_src emacs-lisp :tangle no :noweb-ref notmuch-config
(setq notmuch-search-oldest-first nil)
#+end_src

Fix width of columns in search results
#+begin_src emacs-lisp :tangle no :noweb-ref notmuch-config
(setq notmuch-search-result-format
      '(("date" . "%12s ")
        ("count" . "%-7s ")
        ("authors" . "%-30s ")
        ("subject" . "%-72s ")
        ("tags" . "(%s)")))
#+end_src

Make unread emails specially
#+begin_src emacs-lisp :tangle no :noweb-ref notmuch-config
(setq notmuch-tag-formats
      '(("unread" (propertize tag 'face 'notmuch-tag-unread))))
#+end_src

Set up the sections in the main hello window
#+begin_src emacs-lisp :tangle no :noweb-ref notmuch-config
(setq notmuch-hello-sections
      '(notmuch-hello-insert-header
        notmuch-hello-insert-saved-searches
        notmuch-hello-insert-alltags))
(setq notmuch-show-all-tags-list t)
#+end_src

Setup saved searches. I have a bunch of saved searches in my secret files. If for some reason they aren't loaded I specify some sane defaults. I generally don't use the unread search because it is irrelevant for me (and broken).
#+begin_src emacs-lisp :tangle no :noweb-ref notmuch-config
(setq notmuch-saved-searches
      (if tq/secrets-loaded
          secret/notmuch-saved-searches
        '((:name "inbox"   :query "tag:inbox" :key "i")
          (:name "sent"    :query "tag:sent"  :key "s")
          (:name "drafts"  :query "tag:draft" :key "d")
          (:name "all"     :query "*"         :key "a"))))
#+end_src

Ensure that send mail goes into the correct folder.
#+begin_src emacs-lisp :tangle no :noweb-ref notmuch-config
(setq notmuch-maildir-use-notmuch-insert nil)
(setq notmuch-fcc-dirs (when tq/secrets-loaded secret/notmuch-fcc-dirs))
#+end_src

Ensure that sent mail is sent from the correct address. i.e. the one in the header of the message
#+begin_src emacs-lisp :tangle no :noweb-ref notmuch-config
(setq mail-envelope-from 'header
      mail-specify-envelope-from 'header
      message-sendmail-envelope-from 'header)
#+end_src

I want to use helm to choose which email to send email from. The ~notmuch~ default uses ~ido~ which I do not like. I also want to prompt for a sender whenever I create an email from scratch
#+begin_src emacs-lisp :tangle no :noweb-ref notmuch-config
(defadvice! tq/notmuch-prompt-for-sender ()
  :override #'notmuch-mua-prompt-for-sender
  (let ((name (notmuch-user-name))
        (address (completing-read "From: " (notmuch-user-emails))))
    (message-make-from name address)))

(setq notmuch-always-prompt-for-sender t)
#+end_src

Change the viewer for HTML email to GNUS w3m. It seems to be the best, but idk
#+begin_src emacs-lisp :tangle no :noweb-ref notmuch-config
(setq mm-text-html-renderer 'gnus-w3m)
#+end_src

Allow capturing of email in ~notmuch~
#+begin_src emacs-lisp :tangle no :noweb-ref notmuch-config
(defun tq/org-capture-email ()
  (interactive)
  (let ((org-capture-templates '(("e" "email"
                                  entry (file org-default-notes-file)
                                  "* TODO Reply: %a :email:"
                                  :immediate-finish t))))
    (org-capture nil "e")))

(map! :map notmuch-show-mode-map
      :nv "C" #'tq/org-capture-email)
#+end_src

Use ~org-msg~ to write mixed-mime email in a sane way. I've pinned it to a commit that is currently working. It has given me issues in the past and I can't have it breaking and sending broken email to people.
#+begin_src emacs-lisp :tangle packages.el
(package! org-msg
  :recipe (:host github :repo "jeremy-compostella/org-msg")
  ;; :recipe (:host github :repo "TimQuelch/org-msg")
  :pin "557d490ecbd80522a42f7b1fb6aaacca504d4512")
#+end_src
#+begin_src emacs-lisp
(use-package! org-msg
  :after notmuch
  :config
  (org-msg-mode)
  <<org-msg-config>>
  )
#+end_src

Send email with both HTML and plain text (like a good well adjusted human)
#+begin_src emacs-lisp :tangle no :noweb-ref org-msg-config
(setq org-msg-text-plain-alternative t)
#+end_src

Set up email signature
#+begin_src emacs-lisp :tangle no :noweb-ref org-msg-config
(setq org-msg-signature "\n\nThanks,\n\nTim Quelch\n")
#+end_src

Hack ~notmuch-company~ to allow it to work with ~org-msg-edit-mode~ and enable it.
#+begin_src emacs-lisp :tangle no :noweb-ref org-msg-config
(defadvice! tq/org-msg-notmuch-company (orig-fn &rest args)
  :around #'notmuch-company
  (letf! (((symbol-function 'derived-mode-p) (lambda (mode)
                                               (if (eq mode 'message-mode)
                                                   t
                                                 (derived-mode-p mode)))))
    (apply orig-fn args)))

(set-company-backend!
  '(org-msg-edit-mode notmuch-message-mode)
  'notmuch-company)
#+end_src

Use ~helm-notmuch~ for searching email from helm.
#+begin_src emacs-lisp :tangle packages.el
(package! helm-notmuch :pin "97a01497e079a7b6505987e9feba6b603bbec288")
#+end_src
#+begin_src emacs-lisp
(use-package! helm-notmuch
  :commands helm-notmuch
  :after notmuch)
#+end_src

Disable ~visual-line-mode~ s from message modes
#+begin_src emacs-lisp
(after! message
  (add-hook! 'message-mode-hook
    (visual-line-mode -1)
    (visual-fill-column-mode -1)))
#+end_src

Sometimes I want to send email in both text/HTML or just text. Below are some functions to switch between the two.
#+begin_src emacs-lisp
(after! (:and notmuch org-msg)
  (defun tq/org-msg-to-message ()
    "Transform the current `org-msg' buffer to a `notmuch-message' buffer."
    (interactive)
    (unless (eq major-mode 'notmuch-message-mode)
      (let ((inhibit-read-only t))
        (delete-matching-lines org-keyword-regexp
                               (save-excursion (message-goto-body))
                               (org-msg-end))
        (save-excursion
          (message-goto-body)
          (while (and (< (point) (org-msg-end))
                      (re-search-forward org-property-drawer-re (org-msg-end) t))
            (replace-match "")))

        (let ((text (delete-and-extract-region
                     (save-excursion (message-goto-body))
                     (org-msg-end))))
          (notmuch-message-mode)
          (save-excursion
            (message-goto-body)
            (insert text))))))

  (defun tq/message-to-org-msg ()
    "Transform the current `notmuch-message' buffer to a `org-msg' buffer."
    (interactive)
    (unless (eq major-mode 'org-msg-edit-mode)
      (let ((inhibit-read-only t)
            (text (delete-and-extract-region
                   (save-excursion (message-goto-body))
                   (org-msg-end)))
            (org-msg-signature nil))
        (delete-matching-lines org-msg-separator
                               (save-excursion (message-goto-body))
                               (org-msg-end))
        (org-msg-post-setup)
        (save-excursion
          (goto-char (1- (org-msg-end)))
          (insert text)))))

  (defun tq/trim-org-msg-citation-from-message ()
    "Remove the `org-msg' from the current `notmuch-message' buffer."
    (let ((inhibit-read-only t))
      (unless (= (org-msg-end) (point-max))
        (delete-region (org-msg-end) (point-max)))))

  (add-hook 'message-send-hook #'tq/trim-org-msg-citation-from-message)
  (font-lock-add-keywords 'notmuch-message-mode
                          `((,(regexp-quote org-msg-separator) . 'message-separator))
                          t)

  (defun tq/toggle-message-org-msg ()
    "Toggle between `org-msg' and `notmuch-message' buffers"
    (interactive)
    (cond ((eq major-mode 'org-msg-edit-mode) (tq/org-msg-to-message))
          ((eq major-mode 'notmuch-message-mode) (tq/message-to-org-msg))
          (t (error "Not in an email mode")))

    (message-goto-body)

    ;; Remove extra newlines
    (save-excursion
      (message-goto-body)
      (while (and (< (point) (org-msg-end))
                  (re-search-forward "\n\n\n*" (org-msg-end) t))
        (replace-match "\n\n"))))

  (map! :leader :prefix "e"
        :desc "Toggle text/html" "t" #'tq/toggle-message-org-msg))
#+end_src

Define link hint type for navigating ~notmuch-hello~
#+begin_src emacs-lisp
(after! (link-hint notmuch-hello)
  (defun tq/link-hint--widget-button-at-point-p ()
    "Return point of the customize widget at the point or nil."
    (when (get-char-property (point) 'button) (point)))

  (defun tq/link-hint--next-widget-button (bound)
    "Return pos of the next widget up to BOUND."
    (let ((start (point)))
      (save-excursion
        (widget-forward 1)
        (while (not (tq/link-hint--widget-button-at-point-p))
          (widget-forward 1))
        (when (and (tq/link-hint--widget-button-at-point-p)
                   (> (point) start)
                   (< (point) bound))
          (point)))))

  (defun tq/link-hint--copy-widget (pos)
    "Copy the text of the button at POS."
    (kill-new (widget-get (widget-at pos) :value)))

  (link-hint-define-type 'tq/notmuch-hello
    :next #'tq/link-hint--next-widget-button
    :at-point-p #'tq/link-hint--widget-button-at-point-p
    :vars '(notmuch-hello-mode)
    :open #'widget-button-press
    :copy #'tq/link-hint--copy-widget)
  (push 'link-hint-tq/notmuch-hello link-hint-types))
#+end_src

* Languages
Some extra packages and languages that are not included by doom modules by default

** Systemd unit files
#+begin_src emacs-lisp :tangle packages.el
(package! systemd :pin "51c148e09a129ddf33d95276aa0e89d4ef6f8dd2")
#+end_src
#+begin_src emacs-lisp
(use-package systemd
  :defer t)
#+end_src

** Docker compose
#+begin_src emacs-lisp :tangle packages.el
(package! docker-compose-mode :pin "abaa4f3aeb5c62d7d16e186dd7d77f4e846e126a")
#+end_src
#+begin_src emacs-lisp
(use-package docker-compose-mode
  :defer t)
#+end_src

** Python
Set up LSP to turn off some python warnings
#+begin_src emacs-lisp
(after! lsp-pyls
  (setq! lsp-pyls-plugins-pycodestyle-enabled nil))
#+end_src

** Julia
According to the help for the julia module in doom (=SPC h d m "julia"=, =*Language Server=) I need to manually install =lsp-julia= for some reason,
#+begin_src emacs-lisp :tangle packages.el
(package! lsp-julia :recipe (:host github :repo "non-jedi/lsp-julia"))
#+end_src
#+begin_src emacs-lisp
(after! lsp-julia
  (setq lsp-enable-folding t)
  (setq lsp-julia-default-environment "~/.julia/environments/v1.5"))
#+end_src

** Documents
Use ~nov.el~ for reading ebooks.
#+begin_src emacs-lisp :tangle packages.el
(package! nov :pin "23e5d9c4c63e3a7dc08110a8dfcbb97a1186a37f")
#+end_src
#+begin_src emacs-lisp
(use-package nov
  :mode ("\\.epub\\'" . nov-mode))
#+end_src
